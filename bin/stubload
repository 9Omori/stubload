#!/usr/bin/env bash

# errexit -- exit on errors
set -o errexit

fatal()
{
  # \e[1;31m -- change output to red
  # \e[0m -- change output to default
  local red=$'\e[1;31m'
  local none=$'\e[0m'

  # >&2 -- redirect stdout to stderr
  echo $red"error:"$none "$@"

  if [ "$force" != true ]; then
    return 1
  fi
}

match_entry()
{
  local EFIDUMP=$(efibootmgr | xargs)

  # Boot[0-9]{4}\* -- get 'BootNNNN*' (N = value from 0-9)
  # EFIDUMP -- output of efibootmgr
  for preint in $(grep -E -o 'Boot[0-9]{4}\*' <<<"$EFIDUMP"); do
    # grep -F -- get plain text only, no regex or grep experessions
    if (grep -q -F "$preint $label HD(" <<<"$EFIDUMP"); then
      # //[!0-9] -- remove all non-numbers
      int="${preint//[!0-9]}"
      unset EFIDUMP
      break
    fi
  done
}

entry_exists()
{
  if [ 1 -gt ${#int} ]; then
    match_entry
  fi

  # int should be 4 integers long (e.g. 0001)
  ((${#int} == 4))
}

sub()
{
  _run_main()
  {
    if (command -v _cache_$1); then
      _cache_$main
    fi
    _$main
  }

  main="$1"
  if ((${#NUMARGV[@]} > 0)); then
    for i in ${NUMARGV[@]}; do
      _run_main
    done
  else
    # declare -i -- set integer variable
    declare -i i=1
    while (command -v entry_$i 1>/dev/null); do
      _run_main
      i+=1
    done
  fi
}

version()
{
  local bold=$'\e[1m'
  local none=$'\e[0m'

  VERSION='0.1.4-5'
  VERSION_CODE=17
  TIME='22:56'
  DATE='01/04/2024'
  TZONE='GMT'
  MAINTAINER='alemontn'
  
  EVERSION=$(efibootmgr -V) EVERSION="${EVERSION//[!0-9]}"

  BVERSION=$(
    declare -i i=0
    until (($i == 3)); do
      echo -n ".${BASH_VERSINFO[$i]}"; i+=1
    done
  )
  BVERSION="${BVERSION#.}"

  echo $bold"$VERSION"$none
  echo " Build:   $TIME $DATE [$TZONE]"
  echo " Install: efibootmgr $EVERSION, bash $BVERSION"
}

usage()
{
  # ${0/*\/} -- remove everything before '/' to
  # get just executable name
  echo \
"\
Usage: ${0##*/} [OPTION]...

 -h, --help          print help & exit
 -v, --verbose       don't suppress output
 -V, --version       print version
 -i, --prompt        prompt before performing potentially dangerous actions
 -C, --edit_config   edit configuration file
 -G, --cmdline       get current cmdline
 -A, --add_cmdline   add option to kernel cmdline
 -R, --rm_cmdline    remove option from kernel cmdline
 -l, --list          list entries
 -c, --create        create entries
 -r, --remove        remove entries
 -n[#]               specify entry's number to target

 --force             ignore errors
 --config [file]     specify configuration file
" &&
    exit 0
}

summary()
{
  NUMARGVN="${NUMARGV[@]}" NUMARGVN=(${NUMARGVN// /, })

  if ((${#NUMARGVN[*]} < 1)); then
    NUMARGVN=("all")
  fi

  if [ "${QUEUE[3]}" == "remove_entry" ]; then
    ASK[3]="Remove: ${NUMARGVN[*]}"
  fi

  if [ "${QUEUE[4]}" == "create_entry" ]; then
    ASK[4]="Create: ${NUMARGVN[*]}"
  fi

  if ((${#ASK[@]} > 0)); then
    echo "The following actions will be performed:"

    # '%s\n' -- print each entry in variable and newline
    printf -- '- %s\n' "${ASK[@]}"

    _ask()
    {
      read -p "Is this okay? [y/n] " yn

      case "${yn,,}" in
        "yes"|"y") ret=0 ;;
        "no"|"n") ret=1 ;;
        *) _ask ;;
      esac
      return $ret
    }
    _ask
  fi
}

config_arg()
{
  config="${STRARGV[0]}"
  STRARGV="${STRARGV[*]#$config}"
}

edit_config()
{
  if ((${#EDITOR} < 1)); then
    EDITOR=vi
  fi
  TMP="$config_dir/$config_base-$(date +%s).tmp"

  cp "$config" "$TMP"
  $EDITOR "$TMP"

  if (cmp -s $config $TMP); then
    rm -f "$TMP"
    echo "$config: no changes made"
  else
    mv "$TMP" "$config"
    echo "$config: saved changes"
  fi
}

get_cmdline()
{
  _get_cmdline()
  {
    entry_$i; match_entry

    echo "$i|$unicode"
  }

  sub $FUNCNAME
}

add_cmdline()
{
  _add_cmdline()
  {
    entry_$i

    confin

    orig_unicode="$unicode"
    unicode="$unicode ${STRARGV[@]}"

    echo "${CONFIN/$orig_unicode/$unicode}" >$config
    echo "${STRARGV[@]}: added to cmdline"
  }

  sub $FUNCNAME
}

rm_cmdline()
{
  _rm_cmdline()
  {
    entry_$i

    confin

    orig_unicode="$unicode"
    unicode="${unicode/${STRARGV[@]}}" unicode=$(xargs <<<"$unicode")

    echo "${CONFIN/$orig_unicode/$unicode}" >$config
    echo "${STRARGV[@]}: removed from cmdline"
  }

  sub $FUNCNAME
}

list_entry()
{
  local bold=$'\e[1m'
  local none=$'\e[0m'

  _list_entry()
  {
    entry_$i; match_entry

    if (entry_exists); then
      echo "$int|$i $label"
      if [ "$verbose" == true ]; then
        echo ' '$bold"$target"$none "$unicode"
      fi
    fi
  }

  sub $FUNCNAME
}

remove_entry()
{
  _cache_remove_entry()
  {
    while read line; do
      eval $line
      if (entry_exists); then
        echo "remove: $int"
        efibootmgr -B -b "$int" &>>$log || unset int
      fi
    done </lib/stubload/cachefile
  }

  _remove_entry()
  {
    entry_$i

    echo "remove: $label "
    until (! entry_exists); do
      match_entry
      if ((${#int} == 4)); then
        efibootmgr -B -b "$int" &>>$log &&
          sed "s/int=$int//" </lib/stubload/cachefile | xargs >/lib/stubload/cachefile ||
          unset int
      fi
    done
  }

  sub $FUNCNAME
}

create_entry()
{
  # add a '.' to the front of a script's name to disable it
  for script in $(ls -1 -d /lib/stubload/scripts/*.sh 2>/dev/null); do
    source "$script" &>>$log
  done

  _create_entry()
  {
    entry_$i

    if (entry_exists && ! [ "$force" == true ]); then
      fatal \
        "$label: entry already exists"\
        $'\n'"use '--force' to ignore or '--remove' to replace it"
    fi

    # "${part/ */}" -- get only first string
    part=$(df "$boot_dir" | grep -E '/dev/'); part="${part// *}"
    local part="$part"

    # get path of target relative to mount point
    if (! grep -q " $boot_dir " </proc/mounts); then
      base_mount=$(grep "$part " </proc/mounts | cut -d' ' -f2)
      target="${boot_dir#$base_mount}/$target"
    fi

    case "${part#/dev/}" in
      "nvme"*|"mmcblk"*)
        # '//p*' -- remove 'p' & everything after 'p'
        # '//*p' -- remove 'p' & everything before 'p'
        local disk="${part//p*}"
        local part_int="${part//*p}"
        ;;
      "sd"*)
        # '//[!0-9]' -- remove all non-numbers
        local disk="${part//sd*}"
        local part_int="${part//[!0-9]}"
        ;;
      *)
        fatal "$part: unrecognised disk mapping"
        ;;
    esac

    echo "create: $label "
    efibootmgr -c -d "$disk" -p "$part_int" -L "$label" -l "$target" -u "initrd=\\$ramdisk $unicode" | grep "$label" &>>$log

    match_entry
    echo "int=$int" >>/lib/stubload/cachefile
    unset int
  }

  sub $FUNCNAME
}

main()
{
  for ARG in $@; do
    case "$ARG" in
      "--"*)
        :
        ;;
      "-n"*)
        NUMARGV+=( "${ARG//[!0-9]}" )
        set -- ${@/$ARG}
        ;;
      "-"*)
        # fold -w1 <<<"${ARG/-}" -- add spaces between each argument
        for SHORTARG in $(fold -w1 <<<"${ARG/-}" | xargs); do
          set -- "-$SHORTARG" ${@#-$SHORTARG}
        done
        ;;
    esac
  done

  _queue()
  {
    case "$1" in
      "version"|"usage"|"list_entry"|"remove_entry"|"edit_config"|"cmdline")
        i=3
        ;;
      "create_entry")
        i=4
        ;;
      "add_cmdline"|"rm_cmdline")
        i=2
        ;;
      "summary")
        i=1
        ;;
      "config_arg")
        i=0
        ;;
    esac

    if ((${#QUEUE[$i]} > 0)); then
      fatal "conflicting arguments provided"
    fi

    QUEUE[$i]="$1"
  }

  log=/dev/null

  while (($# > 0)); do
    case "$1" in
      "--force") force=true ;;      
      "--verbose"|"-v") verbose=true log=/dev/stderr ;;
      "--config") _queue "config_arg" ;;
      "--prompt"|"-i") _queue "summary" ;;
      "--version"|"-V") _queue "version" ;;
      "--help"|"-h"|"-?") _queue "usage" ;;
      "--edit_config"|"-C") _queue "edit_config" ;;
      "--cmdline"|"-G") _queue "get_cmdline" ;;
      "--add_cmdline"|"-A") _queue "add_cmdline" ;;
      "--rm_cmdline"|"-R") _queue "rm_cmdline" ;;
      "--list"|"-l") _queue "list_entry" ;;
      "--remove"|"-r") _queue "remove_entry" ;;
      "--create"|"-c") _queue "create_entry" ;;
      "--"*|"-"*) fatal "unrecognised option -- ${1##-}" ;;
      *) STRARGV+=( "$1" ) ;;
    esac
    shift
  done

  if ((${#QUEUE[@]} < 1)); then
    _queue "usage"
  fi

  for each in ${QUEUE[@]}; do
    case "$each" in
      "edit_config"|"get_cmdline"|"add_cmdline"|"rm_cmdline"|"list_entry"|"remove_entry"|"create_entry")
        if [ "$config_srcd" != true ]; then
          source /lib/stubload/config.sh
        fi
        config_srcd=true
        ;;
    esac
    "$each"
  done
}
main $@
