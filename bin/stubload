#!/usr/bin/env bash

# exit on errors
set -o errexit

# get variable definition
source /lib/stubload/common.sh

fatal()
{
  # change output to red
  local red=$(echo -e '\e[1;31m')

  # change output to default
  local none=$(echo -e '\e[0m')

  # >&2 will redirect stdout to stderr
  echo $red"error:"$none >&2

  # until $@ is empty ($# is the count of $@)
  while [ $# -ne 0 ]; do
    echo " $1" >&2; shift
  done

  if [ $force -ne 1 ]; then
    return 1
  fi
}

match_entry()
{
  local EFIDUMP=$(efibootmgr | xargs)

  # Boot[0-9]{4}\* will get 'BootNNNN*' (where N is a number)
  # EFIDUMP is the output of efibootmgr, trapped in a variable to
  # avoid unneeded repetition of efibootmgr, wasting time & CPU usage
  for preint in $(grep -E -o 'Boot[0-9]{4}\*' <<<"$EFIDUMP"); do
    # grep -F will get plain text only, no fancy expressions
    if grep -q -F "$preint $label HD(" <<<"$EFIDUMP"; then
      # remove all non-numbers from int
      int="${preint#Boot}" int="${int/\*}"
      unset EFIDUMP
      # stop for loop
      break
    fi
  done
}

entry_exists()
{
  # get character length of int and compare it to 1
  if [ 1 -gt ${#int} ]; then
    match_entry
  fi

  # int should be 4 integers long (e.g. 0001)
  [ ${#int} -eq 4 ]
}

source_entry()
{
  disabled=0
  entry_$i

  if [ $disabled -ne 0 ]; then
    return 1
  fi

  # assort through ramdisks
  for ramdisk in ${ramdisks[*]}; do
    unicode+=" initrd=$ramdisk"
  done
}

sub()
{
  # check that character length of array NUMARGV is greater than 0
  if [ ${#NUMARGV[*]} -gt 0 ]; then
    for i in ${NUMARGV[*]}; do
      _$1
    done
  else
    # declare -i will set an integer variable
    declare -i i=1
    # 1>/dev/null will send all stdin/stdout to null
    while command -v entry_$i 1>/dev/null; do
      _$1
      # increment i by 1, 1 is taken as an integer and not
      # a string since we declared i as an integer before
      i+=1
    done
  fi
}

version()
{
  local bold=$(echo -e '\e[1m')
  local none=$(echo -e '\e[0m')

  VERSION='0.1.5'
  VERSION_CODE=18
  TIME='00:48'
  DATE='06/04/2024'
  TZONE='GMT'
  MAINTAINER='alemontn'
  
  # capture `efibootmgr -V` in a variable, remove all non-numbers
  EVERSION=$(efibootmgr -V) \
    EVERSION="${EVERSION//[!0-9]}"

  BVERSION=$(
    declare -i i=0
    until [ $i -eq 3 ]; do
      # -n makes sure a newline ('\n') isn't printed
      echo -n ".${BASH_VERSINFO[$i]}"; i+=1
    done
  )
  # remove the first period as it is unneeded
  BVERSION="${BVERSION#.}"

  echo $bold"$VERSION"$none
  echo " Build:   $TIME $DATE [$TZONE]"
  echo " Install: efibootmgr $EVERSION, bash $BVERSION"
}

usage()
{
  # ${0##*/} will remove everything before '/' to get just executable name
  # (e.g. '/usr/bin/stubload' turns to 'stubload')
  # the same result can be achieved using `basename`
  echo \
"\
Usage: ${0##*/} [OPTION]...

 -h, --help          print help & exit
 -v, --verbose       don't suppress output
 -V, --version       print version
 -i, --prompt        prompt before performing potentially dangerous actions
 -C, --edit_config   edit configuration file
 -e, --enable        enable entries
 -d, --disable       disable entries
 -A, --add_cmdline   add option to kernel cmdline
 -R, --rm_cmdline    remove option from kernel cmdline
 -l, --list          list entries
 -c, --create        create entries
 -r, --remove        remove entries
 -n[#]               specify entry's number to target

 --force             ignore errors
 --config=[file]     specify configuration file
" &&
    exit 0
}

summary()
{
  # capture array NUMARGV in NUMARGVN and then replace spaces with commas
  NUMARGVN="${NUMARGV[*]}" \
    NUMARGVN=(${NUMARGVN// /, })

  # compare char count of NUMARGVN to 1
  if [ 1 -gt ${#NUMARGVN[*]} ]; then
    NUMARGVN=("all")
  fi

  # QUEUE[3] will be set to remove_entry if the '-r'|'--remove' arg is provided
  if [ "${QUEUE[2]}" == "remove_entry" ]; then
    ASK[3]="Remove: ${NUMARGVN[*]}"
  fi

  # when '-c'|'--create' is provided
  if [ "${QUEUE[3]}" == "create_entry" ]; then
    ASK[4]="Create: ${NUMARGVN[*]}"
  fi

  if [ ${#ASK[*]} -gt 0 ]; then
    echo "The following actions will be performed:"

    # print each entry in variable and newline
    printf -- ' * %s\n' "${ASK[@]}"

    _ask()
    {
      read -p "Is this okay? [y/n] " yn

      # ,, will change all uppercase to lowercase
      # (^^ will do the opposite)
      case "${yn,,}" in
        "yes"|"y") ret=0 ;;
        "no"|"n") ret=1 ;;
        # repeat if invalid input is given
        *) _ask ;;
      esac
      return $ret
    }
    _ask
  fi
}

edit_config()
{
  if [ 1 -gt ${#EDITOR} ] ; then
    EDITOR=vi
  fi
  # +%s will get unix milliseconds
  TMP="$config_dir/$config_base-$(date +%s).tmp"

  cp "$config" "$TMP"
  $EDITOR "$TMP"

  # cmp -s will compare two files and then redirect all output to null
  if cmp -s $config $TMP; then
    rm -f "$TMP"
    echo "$config: no changes made"
  else
    mv "$TMP" "$config"
    echo "$config: saved changes"
  fi
}

add_cmdline()
{
  _add_cmdline()
  {
    source_entry || return 0

    orig_unicode="$unicode"

    # add all string args to unicode
    unicode+=" ${STRARGV[*]}"

    # $CONFIN will capture the configuration file in a variable to
    # make it easier to deal with and prevent modifications

    # replace $orig_unicode with $unicode in $CONFIN
    echo "${CONFIN/$orig_unicode/$unicode}" >"$config"
    echo "${STRARGV[@]}: added to cmdline for entry $i"
  }

  sub $FUNCNAME
}

rm_cmdline()
{
  _rm_cmdline()
  {
    source_entry || return 0

    orig_unicode="$unicode"
    # remove all strings args from 'unicode'
    unicode="${unicode/${STRARGV[@]}}" unicode=$(xargs <<<"$unicode")

    echo "${CONFIN/$orig_unicode/$unicode}" >"$config"
    echo "${STRARGV[*]}: removed from cmdline for entry $i"
  }

  sub $FUNCNAME
}

entry_scope()
{
  scope="${CONFIN/*entry_$i}"
  scope="${scope/\}*}" \
   scope="${scope/*()*\{}"

  orig_scope="$scope"
}

enable()
{
  _enable()
  {
    source_entry && fatal "entry '$label' is already enabled"

    entry_scope

    scope="${scope/disabled/#disabled}"

    echo "${CONFIN/$orig_scope/$scope}" >"$config"
    echo "$label: enabled"
  }

  sub $FUNCNAME
}

disable()
{
  _disable()
  {
    source_entry || fatal "entry '$label' is already disabled"

    if entry_exists; then
      fatal "entry already exists, remove before disabling"
    fi

    entry_scope

    TAB_SIZE="${scope//[A-Z]*}"
    TAB_SIZE="${TAB_SIZE//[a-z]*}"

    if grep -q "#disabled" <<<"$scope"; then
      scope="${scope/\#disabled/disabled}"
    else
      scope="${TAB_SIZE}disabled"$'\n'"$scope"
    fi

    echo "${CONFIN/$orig_scope/$scope}" >"$config"
    echo "$label: disabled"
  }
  
  sub $FUNCNAME
}

list_entry()
{
  local bold=$(echo -e '\e[1m')
  local none=$(echo -e '\e[0m')

  _list_entry()
  {
    enabled="enabled"
    source_entry || enabled="disabled"

    if entry_exists; then
      exists="$int"
    else
      exists="not created"
    fi

    # int is the boot number according to efibootmgr,
    # i is from the configuration file (entry_i)
    echo "$i: $label ($enabled, $exists)"

    # bash can't handle booleans, so '1' (true) is stored as an integer
    if [ $verbose -eq 1 ]; then
      echo " "$bold"$target"$none "$unicode"
    fi
  }

  sub $FUNCNAME
}

remove_entry()
{
  _remove_entry()
  {
    source_entry || return 0

    echo "remove: $label "
    while entry_exists; do
      match_entry

      if [ ${#int} -eq 4 ]; then
        efibootmgr -B -b "$int" &>>$log ||
          # ignore if efibootmgr's exit status is non-zero
          unset int
      fi
    done
  }

  sub $FUNCNAME
}

create_entry()
{
  # add a '.' to the front of a script's name to disable it,
  # 'ls' will ignore files with '.' unless '-A' or '-a' is given

  # grep will look for files ending in '.sh' (shell scripts)
  for script in $(ls /lib/stubload/scripts | grep -F '.sh' 2>/dev/null); do
    source /lib/stubload/scripts/"$script" &>>$log
  done

  _create_entry()
  {
    source_entry || return 0

    if entry_exists && [ $force -ne 1 ]; then
      fatal \
        "entry '$label' already exists"\
        "use '--force' to ignore or '--remove' to recreate"
    fi

    # "${part/ */}" -- get only first string
    part=$(df "$boot_dir" | grep -E '/dev/'); part="${part// *}"
    local part="$part"

    # get path of target relative to mount point
    if ! grep -q " $boot_dir " </proc/mounts; then
      base_mount=$(grep "$part " </proc/mounts | cut -d' ' -f2)
      mp_dir="${boot_dir#$base_mount}" \
        # replace '/' with '\'
        mp_dir="${mp_dir//\//\\}"

      target="$mp_dir/$target"
      ramdisk="$mp_dir/$ramdisk"
    fi

    # remove /dev/ from part
    # (e.g. /dev/nvme0n1p1 -> nvme0n1p1)
    case "${part#/dev/}" in
      "nvme"*|"mmcblk"*)
        # '//p*' will remove 'p' & everything after 'p'
        # '//*p' is for everything before 'p'
        local disk="${part//p*}"
        local part_int="${part//*p}"
        ;;
      "sd"*)
        # (e.g. sda5 -> sda)
        local disk="${part//[0-9]}"
        # remove all non-numbers from part
        local part_int="${part//[!0-9]}"
        ;;
      *)
        fatal "$part: unrecognised disk mapping"
        ;;
    esac

    echo "create: $label "
    efibootmgr -c -d "$disk" -p "$part_int" -L "$label" -l "$target" -u "$unicode" | grep "$label" &>>$log
  }

  sub $FUNCNAME
}

main()
{
  for ARG in $@; do
    case "$ARG" in
      "--"*)
        :
        ;;
      "-n"*)
        NUMARGV+=( "${ARG//[!0-9]}" )
        # remove NUMARG from all args, since it no longer means anything
        set -- ${@#$ARG}
        ;;
      "-"*)
        # this is for correctly parsing short args,
        # (e.g. -lv -> -l -v)

        # fold -w1 will add spaces between each argument
        for SHORTARG in $(fold -w1 <<<"${ARG/-}" | xargs); do
          set -- "-$SHORTARG" ${@#-$SHORTARG}
        done
        ;;
    esac
  done

  _queue()
  {
    case "$1" in
      # argint makes it so everything arg provided is executed in the correct order
      # (e.g. -c -v -r becomes verbose -> remove_entry -> create_entry)
      "version"|"usage"|"list_entry"|"remove_entry"|"edit_config"|"cmdline")
        argint=2
        ;;
      "create_entry")
        argint=3
        ;;
      "add_cmdline"|"rm_cmdline"|"disable"|"enable")
        argint=1
        ;;
      "summary")
        argint=0
        ;;
    esac

    if [ ${#QUEUE[$argint]} -gt 0 ]; then
      fatal "conflicting arguments provided"
    fi

    QUEUE[$argint]="$1"
    unset argint
  }

  # unless log changes (provided by '-v'|'--verbose' argument),
  # everything sent to log is sent to null
  log=/dev/null

  # until $@ is empty
  while [ $# -ne 0 ]; do
    case "$1" in
      "--force") force=1 ;;      
      "--verbose"|"-v") verbose=1 log=/dev/stderr ;;
      "--config="*) config="${1#*=}" ;;
      "--prompt"|"-i") _queue "summary" ;;
      "--version"|"-V") _queue "version" ;;
      "--help"|"-h"|"-?") _queue "usage" ;;
      "--edit_config"|"-C") _queue "edit_config" ;;
      "--enable"|"-e") _queue "enable" ;;
      "--disable"|"-d") _queue "disable" ;;
      "--add_cmdline"|"-A") _queue "add_cmdline" ;;
      "--rm_cmdline"|"-R") _queue "rm_cmdline" ;;
      "--list"|"-l") _queue "list_entry" ;;
      "--remove"|"-r") _queue "remove_entry" ;;
      "--create"|"-c") _queue "create_entry" ;;
      "--"*|"-"*) fatal "unrecognised option -- ${1##-}" ;;
      *) STRARGV+=( "$1" ) ;;
    esac
    # shift will move $2 (second arg) to $1 (whether its empty or not)
    shift
  done

  if [ 1 -gt ${#QUEUE[@]} ]; then
    _queue "usage"
  fi

  for each in ${QUEUE[@]}; do
    case "$each" in
      # only args that require the configuration file are provided here
      "edit_config"|"add_cmdline"|"rm_cmdline"|"enable"|"disable"|"list_entry"|"remove_entry"|"create_entry")
        if [ $config_srcd -ne 1 ]; then
          source /lib/stubload/config.sh
        fi
        config_srcd=1
        ;;
    esac
    "$each"
  done
}
# keep all args provided to main
main $*
